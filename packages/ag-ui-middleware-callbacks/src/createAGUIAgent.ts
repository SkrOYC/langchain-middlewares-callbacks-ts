/**
 * AG-UI Agent Factory
 * 
 * Creates a LangChain agent with automatic AG-UI protocol integration.
 * 
 * Architecture (SPEC.md Section 2.7):
 * - Uses createAgent() from langchain package
 * - Passes callbacks at runtime via the invoke/stream methods
 * - Uses agent.graph.withListeners for guaranteed cleanup on both success and error
 * - Propagates abort signal from context for client disconnect handling
 */

import { createAgent, type AgentExecutor } from "langchain";
import { AGUICallbackHandler, type AGUICallbackHandlerOptions } from "./callbacks/AGUICallbackHandler";
import { createAGUIMiddleware } from "./middleware/createAGUIMiddleware";
import type { AGUITransport } from "./transports/types";
import type { AGUIMiddlewareOptions } from "./middleware/types";

/**
 * Configuration for creating an AG-UI enabled agent.
 */
export interface AGUIAgentConfig {
  /** The language model to use */
  model: any;
  /** The tools available to the agent */
  tools: any[];
  /** The transport for AG-UI events */
  transport: AGUITransport;
  /** Optional middleware configuration */
  middlewareOptions?: Partial<AGUIMiddlewareOptions>;
  /** Optional callback handler configuration */
  callbackOptions?: AGUICallbackHandlerOptions;
}

/**
 * Shared state for coordinating messageId between middleware and agent wrapper.
 * This allows withListeners cleanup to access the messageId generated by middleware.
 */
interface AgentState {
  activeMessageId: string | undefined;
}

/**
 * Create an AG-UI enabled agent.
 * 
 * This function creates a LangChain agent with automatic AG-UI protocol integration:
 * - Middleware handles lifecycle events (RUN_STARTED, RUN_FINISHED, etc.)
 * - Callbacks handle streaming events (TEXT_MESSAGE_CONTENT, TOOL_CALL_ARGS, etc.)
 * - agent.graph.withListeners provides guaranteed cleanup on both success and error
 * - Abort signal from context enables client disconnect cancellation
 * 
 * @param config - Agent configuration
 * @returns An agent executor with AG-UI protocol support
 */
export function createAGUIAgent(config: AGUIAgentConfig) {
  // Create shared state for coordinating messageId across middleware/callbacks/cleanup
  const agentState: AgentState = {
    activeMessageId: undefined,
  };

  // Create middleware with transport - pass agentState for coordination
  const middleware = createAGUIMiddleware({
    transport: config.transport,
    ...config.middlewareOptions,
    _agentState: agentState, // Internal: share state for cleanup coordination
  });

  // Create callbacks for streaming events with smart emission options
  const aguiCallbacks = [new AGUICallbackHandler(config.transport, config.callbackOptions)];

  // Create base agent with middleware
  const agent = createAgent({
    model: config.model,
    tools: config.tools,
    middleware: [middleware],
  });

  // Use agent.graph.withListeners for guaranteed cleanup on both success and error
  // (SPEC.md Section 8.2 - Ensures TEXT_MESSAGE_END fires even on agent errors)
  // Note: agent.graph is the internal CompiledStateGraph from LangGraph
  const agentWithCleanup = (agent as any).graph?.withListeners?.({
    onStart: (run: any) => {
      // Reset state for new run
      agentState.activeMessageId = undefined;
    },
    onEnd: (run: any) => {
      // Cleanup on successful completion
      cleanupMessageEnd();
    },
    onError: (run: any) => {
      // Cleanup on error (SPEC.md Section 8.2 - Guaranteed cleanup)
      cleanupMessageEnd();
    },
  });

  /**
   * Emit TEXT_MESSAGE_END for cleanup and reset state.
   */
  function cleanupMessageEnd() {
    if (agentState.activeMessageId) {
      try {
        config.transport.emit({
          type: "TEXT_MESSAGE_END",
          messageId: agentState.activeMessageId,
        });
      } catch {
        // Fail-safe: transport errors never crash cleanup
      }
      agentState.activeMessageId = undefined;
    }
  }

  // Return a wrapper that auto-injects AG-UI callbacks and propagates signal
  return {
    invoke: async (input: any, options?: any) => {
      // Extract signal from context if provided
      const signal = options?.signal ?? options?.context?.signal;
      
      // Extract context for transport access
      const context = options?.context ?? {};
      
      const originalCallbacks = [...(options?.callbacks || []), ...aguiCallbacks];
      
      // Use agentWithCleanup if available, otherwise fall back to agent
      const targetAgent = agentWithCleanup ?? agent;
      
      return targetAgent.invoke(input, {
        ...options,
        callbacks: originalCallbacks,
        signal, // Propagate abort signal (SPEC.md Section 3.2)
        context,
      });
    },
    stream: async (input: any, options?: any) => {
      // Extract signal from context if provided
      const signal = options?.signal ?? options?.context?.signal;
      
      // Extract context for transport access
      const context = options?.context ?? {};
      
      const originalCallbacks = [...(options?.callbacks || []), ...aguiCallbacks];
      
      // Use agentWithCleanup if available, otherwise fall back to agent
      const targetAgent = agentWithCleanup ?? agent;
      
      return targetAgent.stream(input, {
        ...options,
        callbacks: originalCallbacks,
        signal, // Propagate abort signal (SPEC.md Section 3.2)
        context,
      });
    },
  };
}
