/**
 * AG-UI Middleware Factory
 *
 * Creates middleware that integrates LangChain agents with the AG-UI protocol.
 *
 * Architecture (SPEC.md Section 2.5):
 * - Middleware handles lifecycle events (RUN_STARTED, RUN_FINISHED, etc.)
 * - Callbacks handle streaming events (TEXT_MESSAGE_CONTENT, TOOL_CALL_ARGS, etc.)
 * - Session ID priority: configurable > context > options
 * - Fail-safe: All transport emissions wrapped in try/catch
 * - State management: Emits STATE_SNAPSHOT and STATE_DELTA events
 * - Guaranteed cleanup: Uses withListeners for error cleanup (via createAGUIAgent)
 */

import { createMiddleware } from "langchain";
import { generateId } from "../utils/idGenerator";
import { computeStateDelta } from "../utils/stateDiff";
import type { AGUIEvent } from "../events";
import type { AGUITransport } from "../transports/types";
import {
  AGUIMiddlewareOptionsSchema,
  type AGUIMiddlewareOptions,
} from "./types";

/**
 * Interface for tracking previous state for delta computation.
 */
interface StateTracker {
  previousState: unknown;
}

/**
 * Create AG-UI middleware for LangChain agents.
 *
 * @param options - Middleware configuration options
 * @returns AgentMiddleware instance with lifecycle hooks
 */
export function createAGUIMiddleware(options: AGUIMiddlewareOptions) {
  // Validate options at creation time
  const validated = AGUIMiddlewareOptionsSchema.parse(options);
  
  // Store transport in closure for access in hooks
  const transport = validated.transport;
  
  // ⚠️ CONCURRENCY WARNING: These closure variables assume single-threaded or serialized invocation.
  // For concurrent usage (same agent instance invoked from multiple requests), developers must
  // serialize agent.invoke() calls per thread_id to avoid race conditions.
  // See SPEC.md Section 9.5: "Concurrency serialization - Serialize invocations per thread_id"
  let threadId: string | undefined;
  let runId: string | undefined;

  // Store current stepName in closure for coordination between beforeModel and afterModel
  let currentStepName: string | undefined = undefined;

  // State tracker for delta computation (only used when emitStateSnapshots === 'all')
  const stateTracker: StateTracker = {
    previousState: undefined,
  };

  return createMiddleware({
    name: "ag-ui-lifecycle",

    /**
     * beforeAgent hook - Runs at the start of agent execution.
     * Emits RUN_STARTED and optionally STATE_SNAPSHOT.
     */
    beforeAgent: async (state, runtime) => {
      // Session ID priority: configurable > context > options (SPEC.md Section 7.1)
      const runtimeAny = runtime as any;
      const configurable = runtimeAny.config?.configurable || runtimeAny.configurable;
      threadId =
        (configurable?.thread_id as string | undefined) ||
        validated.threadIdOverride ||
        (runtimeAny.context?.threadId as string | undefined) ||
        ""; // Fallback for event type compliance

      runId =
        (configurable?.run_id as string | undefined) ||
        (runtimeAny.context?.runId as string | undefined) ||
        generateId(); // Fallback for event type compliance

      // Emit RUN_STARTED event
      try {
        transport.emit({
          type: "RUN_STARTED",
          threadId,
          runId,
        });

          // Emit STATE_SNAPSHOT if configured (SPEC.md Section 4.4)
          if (
            validated.emitStateSnapshots === "initial" ||
            validated.emitStateSnapshots === "all"
          ) {
            transport.emit({
              type: "STATE_SNAPSHOT",
              snapshot: state,
            });
          }
          
          // Emit MESSAGES_SNAPSHOT for message history (SPEC.md Section 4.4)
          const stateAny = state as any;
          if (stateAny.messages) {
            transport.emit({
              type: "MESSAGES_SNAPSHOT",
              messages: stateAny.messages,
            });
          }
        } catch {
         // Fail-safe: Transport errors never crash agent execution
       }

       return {};
    },

    /**
     * beforeModel hook - Runs before each model invocation.
     * Emits TEXT_MESSAGE_START and STEP_STARTED.
     * Note: messageId is generated by callbacks in handleLLMStart using runId as key.
     */
    beforeModel: async (_state, _runtime) => {
      // Generate stepName for step correlation
      const stepName = `model_call_${generateId()}`;
      currentStepName = stepName;

      // Emit STEP_STARTED event (SPEC.md Section 4.1)
      try {
        transport.emit({
          type: "STEP_STARTED",
          stepName,
          runId,
          threadId,
        });
      } catch {
        // Fail-safe
      }

      return {};
    },

    /**
     * afterModel hook - Runs after each model response.
     * Emits TEXT_MESSAGE_END and STEP_FINISHED.
     * Note: messageId is managed by callbacks via handleLLMStart/handleLLMEnd.
     */
    afterModel: async (_state, _runtime) => {
      try {
        // Emit STEP_FINISHED event (SPEC.md Section 4.1)
        transport.emit({
          type: "STEP_FINISHED",
          stepName: currentStepName || "",
          runId,
          threadId,
        });
      } catch {
        // Fail-safe
      }

      // Clear the closure variable
      currentStepName = undefined;

      return {};
    },

    /**
     * afterAgent hook - Runs at the end of agent execution.
     * Emits RUN_FINISHED or RUN_ERROR and optionally STATE_SNAPSHOT/STATE_DELTA.
     * Note: This only runs on successful completion. For guaranteed cleanup on error,
     * withListeners in createAGUIAgent handles TEXT_MESSAGE_END emission.
     */
    afterAgent: async (state, _runtime) => {
      try {
        // Emit STATE_SNAPSHOT if configured (SPEC.md Section 4.4)
        if (
          validated.emitStateSnapshots === "final" ||
          validated.emitStateSnapshots === "all"
        ) {
          transport.emit({
            type: "STATE_SNAPSHOT",
            snapshot: state,
          });
          
          // Emit STATE_DELTA if configured (SPEC.md Section 4.4)
          if (validated.emitStateSnapshots === "all" && stateTracker.previousState !== undefined) {
            const delta = computeStateDelta(stateTracker.previousState, state);
            if (delta.length > 0) {
              transport.emit({
                type: "STATE_DELTA",
                delta,
              });
            }
          }
        }

        // Check for agent error and emit appropriate event
        const stateAny = state as any;
        if (stateAny.error) {
          const error = stateAny.error;
          const errorMessage = error instanceof Error ? error.message : String(error);
          transport.emit({
            type: "RUN_ERROR",
            message:
              validated.errorDetailLevel === "full" ||
              validated.errorDetailLevel === "message"
                ? errorMessage
                : "", // Empty string when error detail is suppressed
            code:
              validated.errorDetailLevel === "full" ||
              validated.errorDetailLevel === "code"
                ? "AGENT_EXECUTION_ERROR"
                : undefined,
          });
        } else {
          transport.emit({
            type: "RUN_FINISHED",
            threadId: threadId!,
            runId: runId!,
          });
        }
      } catch {
        // Fail-safe: Transport errors never crash agent execution
      }

      return {};
    },
  });
}
