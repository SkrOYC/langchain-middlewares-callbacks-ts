/**
 * ACP Callback Handler
 * 
 * Callback handler for emitting events to ACP clients during agent execution.
 * Handles LLM token streaming and tool call lifecycle events.
 * 
 * @packageDocumentation
 */

import { BaseCallbackHandler } from "@langchain/core/callbacks/base";
import type { 
  ContentBlock,
  TextContent,
} from "../types/acp.js";
import type { ContentBlockMapper, DefaultContentBlockMapper } from "../utils/contentBlockMapper.js";
import { defaultContentBlockMapper } from "../utils/contentBlockMapper.js";
import type { ACPCallbackHandlerConfig, ACPConnection } from "../types/middleware.js";

/**
 * Callback handler for ACP protocol streaming events.
 * Extends BaseCallbackHandler to integrate with LangChain's callback system
 * and emit events to ACP-compatible clients.
 * 
 * This handler manages:
 * - LLM token streaming via handleLLMNewToken → agent_message_chunk
 * - Tool lifecycle events: start/end/error → tool_call/tool_call_update
 * - State snapshot updates for real-time agent communication
 */
export class ACPCallbackHandler extends BaseCallbackHandler {
  name = "acp-callback-handler";
  
  protected connection: ACPConnection;
  protected contentBlockMapper: ContentBlockMapper;
  protected emitTextChunks: boolean;
  protected includeIntermediateStates: boolean;
  protected maxMessagesInSnapshot: number;
  
  private currentMessageId: string | null = null;
  private currentTextContent: string = "";
  private currentToolCallId: string | null = null;
  private sessionId: string | null = null;

  constructor(config: ACPCallbackHandlerConfig) {
    super();
    
    this.connection = config.connection;
    this.sessionId = config.sessionId ?? null;
    this.contentBlockMapper = config.contentBlockMapper ?? defaultContentBlockMapper;
    this.emitTextChunks = config.emitTextChunks ?? false;
    this.includeIntermediateStates = config.includeIntermediateStates ?? true;
    this.maxMessagesInSnapshot = config.maxMessagesInSnapshot ?? 50;
  }

  /**
   * Dispose of the callback handler and close the connection.
   */
  async dispose(): Promise<void> {
    try {
      await this.connection.close();
    } catch {
      // Fail-safe: don't let close errors break disposal
    }
  }

  /**
   * Sets the session ID for this callback handler.
   * Should be called by the session middleware before agent execution.
   * 
   * @param sessionId - The session ID to use for session updates
   */
  setSessionId(sessionId: string): void {
    this.sessionId = sessionId;
  }

  /**
   * Gets the current session ID.
   */
  getSessionId(): string | null {
    return this.sessionId;
  }

  /**
   * Called when an LLM starts processing.
   * 
   * @param _llm - The LLM being used
   * @param _prompts - The prompts sent to the LLM
   * @param runId - The run ID for this LLM call
   * @param _parentRunId - The parent run ID if this is a nested call
   * @param _extraParams - Additional parameters
   * @param _tags - Optional tags for this LLM call
   * @param _metadata - Optional metadata for this LLM call
   * @param _runName - Optional run name
   */
  override async handleLLMStart(
    _llm: any,
    _prompts: string[],
    runId: string,
    _parentRunId?: string,
    _extraParams?: Record<string, unknown>,
    _tags?: string[],
    _metadata?: Record<string, unknown>,
    _runName?: string
  ): Promise<void> {
    // Generate a new message ID for this LLM response
    this.currentMessageId = this.generateMessageId();
    this.currentTextContent = "";
  }

  /**
   * Called when a new token is generated by the LLM.
   * This is the primary method for streaming LLM output to ACP clients.
   * 
   * @param token - The new token generated by the LLM
   * @param _idx - Token index information
   * @param runId - The run ID for this LLM call
   * @param _parentRunId - The parent run ID if this is a nested call
   * @param _tags - Optional tags
   * @param fields - Additional fields
   */
  override async handleLLMNewToken(
    token: string,
    _idx: any,
    runId: string,
    _parentRunId?: string,
    _tags?: string[],
    fields?: any
  ): Promise<void> {
    if (!this.currentMessageId) {
      this.currentMessageId = this.generateMessageId();
    }

    // Accumulate text content
    this.currentTextContent += token;

    // Emit agent message chunk to ACP client
    try {
      await this.sendAgentMessageChunk(
        this.currentMessageId,
        token,
        this.currentTextContent
      );
    } catch {
      // Fail-safe: don't let emit errors break agent execution
    }
  }

  /**
   * Called when an LLM call ends.
   * 
   * @param _output - The output from the LLM
   * @param runId - The run ID for this LLM call
   * @param _parentRunId - The parent run ID if this is a nested call
   * @param _tags - Optional tags
   * @param _extraParams - Additional parameters
   */
  override async handleLLMEnd(
    _output: any,
    runId: string,
    _parentRunId?: string,
    _tags?: string[],
    _extraParams?: Record<string, unknown>
  ): Promise<void> {
    if (this.currentMessageId) {
      try {
        // Send final agent message with complete content
        const content = this.currentTextContent;
        const textContent: TextContent & { type: "text" } = {
          type: "text",
          text: content,
          _meta: null,
          annotations: null,
        };
        
        await this.connection.sendAgentMessage({
          messageId: this.currentMessageId,
          role: "agent",
          content: [textContent as ContentBlock],
          contentFormat: "text",
        });
      } catch {
        // Fail-safe: don't let emit errors break agent execution
      }
      
      this.currentMessageId = null;
      this.currentTextContent = "";
    }
  }

  /**
   * Called when an LLM call encounters an error.
   * 
   * @param _error - The error that occurred
   * @param runId - The run ID for this LLM call
   * @param _parentRunId - The parent run ID if this is a nested call
   */
  override async handleLLMError(
    _error: Error,
    runId: string,
    _parentRunId?: string
  ): Promise<void> {
    if (this.currentMessageId) {
      try {
        await this.connection.sendAgentMessage({
          messageId: this.currentMessageId,
          role: "agent",
          content: [
            {
              type: "text",
              text: `Error: ${_error.message}`,
              _meta: null,
              annotations: null,
            } as ContentBlock,
          ],
          contentFormat: "text",
        });
      } catch {
        // Fail-safe: don't let emit errors break agent execution
      }
      
      this.currentMessageId = null;
      this.currentTextContent = "";
    }
  }

  /**
   * Called when a tool starts execution.
   * 
   * @param tool - The tool being executed
   * @param input - The input to the tool
   * @param runId - The run ID for this tool call
   * @param _parentRunId - The parent run ID if this is a nested call
   * @param _tags - Optional tags
   * @param _metadata - Optional metadata
   * @param _runName - Optional run name
   */
  override async handleToolStart(
    tool: any,
    input: string,
    runId: string,
    _parentRunId?: string,
    _tags?: string[],
    _metadata?: Record<string, unknown>,
    _runName?: string
  ): Promise<void> {
    // Extract tool name from various possible locations
    const toolName = tool?.name || 
                   tool?.kwargs?.name || 
                   tool?._name || 
                   tool?.func?.name || 
                   "unknown_tool";
    
    this.currentToolCallId = this.generateToolCallId();
    
    try {
      await this.sendToolCallStart(this.currentToolCallId, toolName, input);
    } catch {
      // Fail-safe: don't let emit errors break agent execution
    }
  }

  /**
   * Called when a tool call ends.
   * 
   * @param output - The output from the tool
   * @param runId - The run ID for this tool call
   * @param _parentRunId - The parent run ID if this is a nested call
   */
  override async handleToolEnd(
    output: any,
    runId: string,
    _parentRunId?: string
  ): Promise<void> {
    if (this.currentToolCallId) {
      try {
        await this.sendToolCallEnd(this.currentToolCallId, "completed", output);
      } catch {
        // Fail-safe: don't let emit errors break agent execution
      }
      
      this.currentToolCallId = null;
    }
  }

  /**
   * Called when a tool call encounters an error.
   * 
   * @param _error - The error that occurred
   * @param runId - The run ID for this tool call
   * @param _parentRunId - The parent run ID if this is a nested call
   */
  override async handleToolError(
    _error: Error,
    runId: string,
    _parentRunId?: string
  ): Promise<void> {
    if (this.currentToolCallId) {
      try {
        await this.sendToolCallEnd(
          this.currentToolCallId, 
          "failed", 
          _error.message,
          _error.message
        );
      } catch {
        // Fail-safe: don't let emit errors break agent execution
      }
      
      this.currentToolCallId = null;
    }
  }

  /**
   * Sends an agent message chunk to the ACP client.
   * 
   * @param messageId - Unique identifier for this message
   * @param delta - The text delta to send
   * @param currentText - The accumulated text so far
   */
  private async sendAgentMessageChunk(
    messageId: string,
    delta: string,
    currentText: string
  ): Promise<void> {
    const textContent: TextContent & { type: "text" } = {
      type: "text",
      text: delta,
      _meta: null,
      annotations: null,
    };
    
    await this.connection.sendAgentMessage({
      messageId,
      role: "agent",
      content: [textContent as ContentBlock],
      contentFormat: "text",
      delta: {
        type: "text",
        text: delta,
      },
    });
  }

  /**
   * Generates a unique message ID.
   * Uses a combination of timestamp, counter, and random suffix for uniqueness.
   */
  private generateMessageId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const counter = (this as any)._messageCounter ?? ((this as any)._messageCounter = 0);
    (this as any)._messageCounter = counter + 1;
    return `msg-${timestamp}-${counter}-${random}`;
  }

  /**
   * Generates a unique tool call ID.
   * Uses a combination of timestamp, counter, and random suffix for uniqueness.
   */
  private generateToolCallId(): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 8);
    const counter = (this as any)._toolCallCounter ?? ((this as any)._toolCallCounter = 0);
    (this as any)._toolCallCounter = counter + 1;
    return `tool-${timestamp}-${counter}-${random}`;
  }

  /**
   * Detects the tool kind from the tool name.
   * Maps common tool names to appropriate ACP tool kinds.
   * 
   * @param toolName - The name of the tool
   * @returns The detected tool kind
   */
  private detectToolKind(toolName: string): "read" | "edit" | "delete" | "move" | "search" | "execute" | "think" | "fetch" | "switch_mode" | "other" {
    const name = toolName.toLowerCase();
    
    if (name.includes("read") || name.includes("file") || name.includes("load") || name.includes("get")) {
      return "read";
    }
    if (name.includes("write") || name.includes("edit") || name.includes("create") || name.includes("update") || name.includes("modify")) {
      return "edit";
    }
    if (name.includes("delete") || name.includes("remove") || name.includes("rm")) {
      return "delete";
    }
    if (name.includes("move") || name.includes("rename") || name.includes("mv")) {
      return "move";
    }
    if (name.includes("search") || name.includes("find") || name.includes("grep") || name.includes("query")) {
      return "search";
    }
    if (name.includes("exec") || name.includes("run") || name.includes("command") || name.includes("shell") || name.includes("bash") || name.includes("cmd")) {
      return "execute";
    }
    if (name.includes("think") || name.includes("reason") || name.includes("analyze")) {
      return "think";
    }
    if (name.includes("fetch") || name.includes("http") || name.includes("request") || name.includes("api") || name.includes("url")) {
      return "fetch";
    }
    if (name.includes("mode") || name.includes("switch")) {
      return "switch_mode";
    }
    
    return "other";
  }

  /**
   * Sends a session update for tool call creation.
   * 
   * @param toolCallId - Unique identifier for the tool call
   * @param toolName - Name of the tool being called
   * @param input - Input parameters for the tool
   */
  private async sendToolCallStart(
    toolCallId: string,
    toolName: string,
    input: string
  ): Promise<void> {
    if (!this.sessionId) {
      // Fallback: emit as agent message if no session ID
      await this.connection.sendAgentMessage({
        messageId: this.generateMessageId(),
        role: "agent",
        content: [
          {
            type: "text",
            text: `Calling tool: ${toolName}`,
            _meta: null,
            annotations: null,
          } as ContentBlock,
        ],
        contentFormat: "text",
      });
      return;
    }

    await this.connection.sessionUpdate({
      sessionId: this.sessionId,
      update: {
        sessionUpdate: "tool_call",
        toolCallId,
        title: `Calling tool: ${toolName}`,
        kind: this.detectToolKind(toolName),
        status: "in_progress",
        rawInput: input,
      },
    });
  }

  /**
   * Sends a session update for tool call completion.
   * 
   * @param toolCallId - Unique identifier for the tool call
   * @param status - Completion status (completed or failed)
   * @param output - Output from the tool
   * @param errorMessage - Error message if failed
   */
  private async sendToolCallEnd(
    toolCallId: string,
    status: "completed" | "failed",
    output: unknown,
    errorMessage?: string
  ): Promise<void> {
    if (!this.sessionId) {
      // Fallback: emit as agent message if no session ID
      const content = status === "completed" 
        ? `Tool completed: ${output}`
        : `Tool error: ${errorMessage || output}`;
      
      await this.connection.sendAgentMessage({
        messageId: this.generateMessageId(),
        role: "agent",
        content: [
          {
            type: "text",
            text: content,
            _meta: null,
            annotations: null,
          } as ContentBlock,
        ],
        contentFormat: "text",
      });
      return;
    }

    const contentBlock = status === "completed" 
      ? [{
          type: "text" as const,
          text: String(output),
          _meta: null,
          annotations: null,
        }]
      : [{
          type: "text" as const,
          text: errorMessage || String(output),
          _meta: null,
          annotations: null,
        }];

    await this.connection.sessionUpdate({
      sessionId: this.sessionId,
      update: {
        sessionUpdate: "tool_call_update",
        toolCallId,
        status,
        content: contentBlock as ContentBlock[],
        rawOutput: output,
        _meta: null,
      },
    });
  }
}

/**
 * Factory function for creating an ACPCallbackHandler.
 * 
 * @param config - Configuration options for the callback handler
 * @returns A new ACPCallbackHandler instance
 * 
 * @example
 * ```typescript
 * const handler = createACPCallbackHandler({
 *   connection: agentConnection,
 *   emitTextChunks: true,
 * });
 * ```
 */
export function createACPCallbackHandler(
  config: ACPCallbackHandlerConfig
): ACPCallbackHandler {
  return new ACPCallbackHandler(config);
}